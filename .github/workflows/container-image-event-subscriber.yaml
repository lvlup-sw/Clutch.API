# This action will listen to events emitted by the API
# For now, to build images we will pull from DockerHub
# https://github.com/marketplace?query=Azure

# Control Flow:
# 1. Receive event from ASB
# 2. Extract image data from event
# 3. Check to see if image is in ACR already
# 4. If not, pull down from Docker Hub and build
# 5. Upload image to ACR

name: Image Event Listener

# Trigger on Webhook
on:
  repository_dispatch:

# Only allow one instance running at a time
#concurrency:
#  group: 'service-bus-processing' 
#  cancel-in-progress: false 
# Since we are only ever updating 1-2 values
# at a time, this may not be necessary. We
# would need to consider how to handle concurrent
# transactions (locks?) within the database.

jobs:
  handle_event:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          npm install @azure/service-bus
          npm install @actions/core

      # Custom action which emits
      # parsed event as an output
      - name: Receive Message from Azure Service Bus
        id: receive_message
        uses: ./.github/actions/receive-event-from-asb
        with:
          connectionString: ${{ secrets.AZURE_SERVICE_BUS_CONNECTION_STRING }}
          queueName: ${{ vars.AZURE_SERVICE_BUS_QUEUE_NAME }}

      - name: Extract Event Data
        id: extract_event
        run: |
          eventName=$(echo '${{ steps.receive_message.outputs.eventName }}' | cut -d',' -f1 | cut -d':' -f2 | tr -d ' ')
          echo "eventName=$eventName" >> $GITHUB_OUTPUT        
          echo "repositoryName=$(echo '${{ steps.receive_message.outputs.eventData }}' | jq -r '.repositoryId')" >> $GITHUB_OUTPUT
          echo "tag=$(echo '${{ steps.receive_message.outputs.eventData }}' | jq -r '.tag')" >> $GITHUB_OUTPUT
          echo "baseImageName=$(echo '${{ steps.receive_message.outputs.eventData }}' | jq -r '.repository')" >> $GITHUB_OUTPUT
          echo "registryType=$(echo '${{ steps.receive_message.outputs.eventData }}' | jq -r '.registryType')" >> $GITHUB_OUTPUT

      - name: Set Requested Operation Based on Event
        id: get_operation
        run: |
          echo "${{ steps.extract_event.outputs.eventName }}"
          echo "${{ steps.extract_event.outputs.repositoryName }}"
          echo "${{ steps.extract_event.outputs.registryType }}"
          actualEventName=$(echo '${{ steps.extract_event.outputs.eventName }}' | jq -r '.EventName')
          
          if [ "$actualEventName" == "BuildRequested" ]; then
            echo "operation=update" >> $GITHUB_OUTPUT
          elif [ "$actualEventName" == "DeleteRequested" ]; then
            echo "operation=delete" >> $GITHUB_OUTPUT
          else
            echo "::error::Invalid eventName: $actualEventName"
            exit 1
          fi

      - name: Azure login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      # Validate this
      - name: Check if Image Exists in ACR
        id: check_image
        run: |
          exists=$(az acr repository show-manifests \
            --name <your-acr-name> \
            --repository ${{ steps.extract_event.outputs.repositoryName }} \
            --query "[?tags[0]=='${{ steps.extract_event.outputs.tag }}'].digest" \
            --output tsv)

          if [ -z "$exists" ]; then
            echo "imageExists=false" >> $GITHUB_OUTPUT
          else
            echo "imageExists=true" >> $GITHUB_OUTPUT
          fi

      - name: Login to ACR
        uses: docker/login-action@v3
        with:
          registry: ${{ vars.AZURE_CONTAINER_REGISTRY_NAME }}
          username: ${{ secrets.AZURE_CLIENT_ID }}
          password: ${{ secrets.AZURE_CLIENT_SECRET }}

      # Validate this
      - name: Build and Push Image
        if: steps.extract_event.outputs.eventName == 'BuildRequested' && steps.check_image.outputs.imageExists == 'false'
        run: |
          docker pull ${{ steps.extract_event.outputs.repositoryName }}
          docker build -t ${{ steps.extract_event.outputs.baseImageName }}:${{ steps.extract_event.outputs.tag }} \
            --build-arg BASE_IMAGE=${{ steps.extract_event.outputs.baseImageName }} . 

      # Validate this
      - name: Tag and Push to ACR
        run: |
          docker tag ${{ steps.extract_event.outputs.repositoryName }}:${{ steps.extract_event.outputs.tag }} <your-acr-name>.azurecr.io/${{ steps.extract_event.outputs.repositoryName }}:${{ steps.extract_event.outputs.tag }}
          docker push ${{ vars.AZURE_CONTAINER_REGISTRY_NAME }}/${{ steps.extract_event.outputs.repositoryName }}:${{ steps.extract_event.outputs.tag }}

      - name: Update Database
        id: update_db
        uses: ./.github/actions/update-database
        with:
          postgresql_connection_string: ${{ secrets.POSTGRESQL_CONNECTION_STRING }}
          table_to_update: 'container_images'
          index_to_update: ${{ steps.extract_event.outputs.repositoryName }}
          operation: ${{ steps.get_operation.outputs.operation }}
          update_value: '0' 